# 이산수학의 개념
이산수학은 이산(Discrete)과 수학(Mathematics)이 결합된 개념으로, 이산은 연속(continuous)과 반대되는 개념으로, 서로 구별될 수 있는 부분들로 이루어진 것을 말한다.

이산의 개념이 중요한 이유는, 다루는 데이터가 이산적이냐 연속적이냐에 따라 디지털 컴퓨터와 아날로그 컴퓨터로 구분되기 때문이다.

한편, 수학이란 수학적 대상의 성질들을 연구하는 학문이다. 여기서 수학적 대상이란 존재하는 것과 존재하지 않는 모든 추상적인 것을 말한다. 추상화란 현실에 존재하는 현상에서 공통적인 사실을 추출하는 것이다.

# 정수론 *number theory*
정수론이란 정수(Integer)의 성질들을 연구하는 학문이다. 현대 암호학은 주로 정수론의 수학적 성질을 활용하기에, 암호화 알고리즘의 이해와 구현을 위해서는 정수론의 이해는 필수적이다.

대표적인 비대칭 키 암호화 알고리즘인 RSA의 경우, 이산 로그(Discrete Logarithm) 문제를 바탕으로 한다.

프로그래밍에서 다양한 알고리즘을 이해하기 위해서는 소수의 성질과 나머지(mod) 연산 등 정수론의 기본적인 사항들을 이해하여야 한다.

자연수(natural number)와 정수의 간단한 성질들을 살펴보자. 729라는 수를 생각해보자.

729는 100이 7개, 10이 2개, 1이 9개 합쳐져 구성된 수이다. 그러나 이런 식의 설명 방법은 1, 10, 100이란 수의 이해와 곱셈과 덧셈의 이해를 요한다.

그렇기에 우리는 729를 728보다 하나 더 큰 수, 728을 727보다 하나 더 큰 수.. 이런 식으로 정의하여 1과 덧셈의 이해만으로 설명할 수 아주 단순하게 설명할 수 있다.

이러한 방법을 자연수에 대한 **공리적 접근 방식**이라고 한다. 공리적인 접근 방식은 기본항과 공리(axiom)들을 가지고 정의한다.

## 자연수에 대한 공리적 접근 방식
이탈리아 수학자 주세페 페아노(Giuseppe Peano)는 기본 항으로 '1', 'successor', '자연수' 를 갖는 공리를 제시했다.

### 자연수에 대한 공리

 1. 1은 자연수이다.
 2. 각각의 자연수는 오직 하나의 successor만을 갖는다.
 3. 1은 어떠한 자연수의 successor가 아니다.
 4. 만약 Succ(x) = Succ(y)이면 x = y이다.
 5. 만약 M이 다음을 만족하는 자연수들의 부분집합이면, M은 모든 자연수들의 집합니다.
	 1. 1 ∈M
	 2. x∈M => Succ(x)∈M

공리 5의 1에서 p(1)이 참임을 알 수 있고, 공리 5의 2를 통해 모든 p(n)에 대해 p(n)이 참이면 p(n+1)이 참임을 알 수 있으므로 1,2,3... 이 모두 자연수임을 알 수 있다.

## 닫힘 성질
닫힘 성질(closure property)이란 어떤 집합 A의 원소 간의 이항 연산의 결과 역시 집합 A의 원소가 되는 성질이다.

즉, "집합 A가 연산 F에 대해 닫혀있다."는 것은 A의 임의의 원소 a, b에 대해 F(a,b) 역시 A의 원소가 된다는 것이다.

앞에서 정의한 자연수는 덧셈과 곱셈에 대하여 닫혀있다. 즉, 2개의 자연수들의 합과 곱은 다시 자연수가 된다.

그러나 자연수는 뺄셈과 나눗셈에 대해서는 닫혀잇지 않다. 이러한 성질에 의해 우리가 어릴 적에 배운 덧셈과 곱셈의 교환법칙과 결합법칙 등이 성립하는 것이다.

## 항등원
어떤 연산에 대해 닫혀있는 집합이 존재할 때, 이 집합의 원소와 이항 연산을 했을 때 그 원소를 값으로 갖는 원소가 유일한 경우, 이 원소를 항등원(identity element)이라 한다.

자연수에서 곱셈 연산자의 항등원은 자연수 a에 대하여 a * k = a가 성립하는 k를 찾는 것이다. 그러므로 곱셈 연산자의 항등원은 1이 된다. 반면에 덧셈 연산자에서의 항등원은 어떨까? 0을 넣으면 a + k = a가 항상 성립하겠지만 0은 자연수가 아니므로 자연수에서 덧셈 연산자의 항등원은 없다.

## 정렬순서 원리
정렬순서 원리(well-ordering principle)란 어떤 집합에 대해서 공집합이 아닌 임의의 모든 부분집합들은 각각 하나의 최소 원소(least element)를 갖는다는 것이다.

정렬순서 원리는 집합의 원소들 사이에 순서가 잘 정해져 있어서, 그 집합이 (공집합이 아닌) 어떤 부분집합에서도 최소 원소가 있을 때, 그 집합을 정렬되었다고 한다. 자연수의 집합에서 공집합이 아닌 임의의 부분집합을 잡아도 그 부분집합에는 최소 원소가 존재한다. 그러므로 자연수는 정렬순서 원리이다.

정렬순서 원리의 이해를 위해서는 순서 관계(order relation)를 먼저 이해해야 한다. 어떤 집합이 순서 관계를 가지려면 다음에 만족해야 한다.

- 두 원소 x, y가 다르다면 x>y이거나 x<y이다.
- 임의의 x에 대해서 x>x이거나 x<x는 성립하지 않는다.
- x>y이고 y>z이면 x>z이다.

## 정수의 성질
정수(Integer)는 자연수와 자연수들의 음수, 0으로 이루어진 수 체계이다. 자연수와 마찬가지로 셀 수 있는 무한집합이며, 덧셈과 뺄셈, 곱셈에 대해서 닫혀있다.

두 정수 n, m에 대하여 n≠0 이라면 n의 배수들을 직선(real line)위에 나타낼 수 있다. 또한, `m=an+r (0≤r≤n)`의 형태로 나타낼 수 있다.

이때, r=0 이라면, m은 n의 배수이며 `n | m`이라 쓰고 n은 m을 나눈다(divide)라고 한다.

## 소수
소수(prime number)는 나누어짐을 바탕으로 한 중요한 개념 중 하나이다. 소수란 약소로 1과 자기 자신만을 갖는 1보다 큰 정수를 말한다. 소수는 현대 암호 시스템에서 필수적인 개념이다.

또한, 소수가 아닌 1보다 큰 양의 정수를 합성수(composite number)라고 부른다.

소수를 판별하는 방법 중 가장 단순한 것은 시행착오(trial and error)이다. 29가 소수인지를 판단하라고 하면, 29를 2부터 시작해서 3, 5 등으로 계속해서 나눠 볼 수 있다. 이때 29까지 나누어지는 수가 없으면 29는 소수라고 볼 수 있다.

그러나 2<sup>42</sup>-1이 소수냐고 묻는다면, 이러한 큰 수는 시행착오로 찾아보기 쉽지 않다.

소수인지를 빠르게 판별하는 알고리즘은 후에 배워보자.

현재 가장 큰 2<sup>n</sup>-1의 형태를 갖는 메르센 소수를 찾는 연구가 진행 중이다.

### 에라토스테네스의 체
어떤 수에 대해서 그 수를 초과하지 않는 모든 소수를 찾아내는 방법으로 에라토스테네스의 체(sieve of Eratosthenes)가 있다.

50보다 작은 소수를 구한다고 할 때, 1은 소수가 아니므로 지우고, 소수 2는 남기고 2의 배수를 모두 지운다. 같은 방식으로 소수 3,5,7은 지우고 그 배수는 모두 지운다. 이런 방식으로 남은 소수들을 찾을 수 있다.

## 공약수
이제 두 수에 대한 공약수(common divisor)를 생각해보자. a, b, k가 양의 정수이며, k가 k | a 이고 k | b 이면 k를 a와 b의 공약수라 한다. a와 b의 공약수 중에서 가장 큰 공약수를 k'라 하면, k'는 a와 b의 최대공약수(Greatest Common Divisor, GCD)라 하고 `k' = GCD(a,b)`로 나타낸다.

# 행렬 *matrix*
값들을 행과 열로 나열하는 것을 행렬이라고 한다. 행렬은 연립방정식(Simultaneous Equation)을 풀기 위해 개발된 개념으로 수, 문자, 함수 등을 네모꼴 괄호 안에 배열하여 놓은 것을 말한다. 행렬의 각 성분은 실수여야 하고, 이를 스칼라(Scalar)라고 한다.

| a<sub>11</sub> | a<sub>12</sub> | a<sub>13</sub>| ... | a<sub>1n</sub>|
|--|--|--|--|--|
| a<sub>21</sub> | a<sub>22</sub> | a<sub>23</sub>| ... | a<sub>2n</sub>|

각각이 n쌍으로 된 m개의 수평 성분 (a<sub>i1</sub>, a<sub>i2</sub> ... a<sub>in</sub>)을 행(row)이라 하고, 각각이 m 쌍으로 된 n개의 수직 성분 (a<sub>1j</sub>, a<sub>2j</sub> ... a<sub>mj</sub>)을 열(column)이라 한다.

이러한 행렬을 m X n 행렬이라 하고, m by n 행렬이라고 읽는다.

## 행렬의 덧셈
행렬 A와 B가 같은 크기의 행과 열을 갖는다고 하면, 행렬 A와 B의 합을 A+B로 표시하고 A+B = (a<sub>ij</sub>) + (b<sub>ij</sub>) = (a<sub>ij</sub> + b<sub>ij</sub>)이다. 즉, 대응하는 성분끼리의 합을 구하면 된다.

각 성분이 0인 행렬을 영행렬(zero matrix)이라 한다.

## 행렬의 곱
A는 m X p 행렬이고 B는 p X n 행렬이라 하자. 그러면 A와 B의 행렬곱 AB는 m X n 행렬이고 C = c<sub>ij</sub>가 된다.

c<sub>ij</sub> = a<sub>i1</sub>b<sub>1j</sub> + a<sub>i2</sub>b<sub>2j</sub> + ... + a<sub>ip</sub>b<sub>pj</sub>

즉 행렬의 곱을 구하기 위해서는 A의 열의 개수와 B의 행의 개수가 같아야 한다.

### 행렬곱과 프로그래밍
```python
def dot(A,B,C):
	for i in range(m):
		for j in range(s):
			c[i][j] = 0
			for k in range(n):
				c[i][j] = c[i][j] + a[i][k] * b[k][j]
```

위 알고리즘은 흔히 행렬곱을 계산하기 위해 쓰이는 코드이다.

이 알고리즘을 프로그래밍 언어를 달리하여 적용해보면 실행 시간에 차이가 나는 것을 볼 수 있는데, 이는 일반적으로 프로그래밍 언어들이 2차원 이상의 행렬을 메모리에 저장할 때, 1차원으로 저장하기 위해 행 우선(row major)이나 열 우선(column major)으로 저장하는 방법에 따라 각각의 원소들을 액세스하는 시간이 차이가 나기 때문이다. 공간 지역성과 시간 지역성에 따라 차이가 난다.

행 우선 방법의 대표적 언어는 C언어이고, 열 우선 방법의 대표적 언어는 Fortran 언어이다.

## 특수 행렬
행과 열의 수가 n으로 같은 행렬을 n차 정방 행렬(square matrix)이라고 하며, 이때 행 또는 열의 개수를 정방 행렬의 차수라고 한다.

n차 정방 행렬에서 대각선상에 위치한 원소, 즉 a<sub>ii</sub>(i=1,2,3, ..., n)를 주대각(main diagonal) 원소라고 하며, 주대각 원소를 제외한 나머지 원소(off-diagonal)가 모두 0인 행렬을 대각 행렬(diagonal matrix)이라고 한다.

정방 행렬에서는 대각 행렬을 포함해서 여러 가지 특수한 성질을 갖는 행렬이 있다.

### 대각 행렬 *Diagonal Matrix*

```
[[2, 0],
 [0, 3]]
```
 
### 단위 행렬 *Identity Matrix*
단위 행렬(또는 항등 행렬)은 주대각 원소들은 모두 1이고, 주대각 원소를 제외한 원소들은 0인 정방 행렬이다.

```
[[1, 0, 0].
 [0, 1, 0],
 [0, 0, 1]]
```

### 스칼라 행렬 *Scalar Matrix*
스칼라 행렬은 주대각 원소들이 모두 같은 값을 갖는 대각 행렬이다.
```
[[4, 0, 0],
 [0, 4, 0].
 [0, 0, 4]]
 ```

### 전치 행렬 *Transpose Matrix*
전치 행렬은 임의의 m X n 행렬 A에 대해 행과 열을 바꾸어서 얻어진 n X m을 말한다. 이 행렬을 A의 전치행렬 A<sup>T</sup>로 나타낸다.

### 대칭 행렬 *Symmetric Matrix*
자신과 자신의 전치 행렬이 같은 행렬을 대칭 행렬이라고 한다.

### 삼각 행렬 *Triangular Matrix*
삼각 행렬은 상삼각 행렬과 하삼각 행렬로 나뉘는데, 각각 주대각 원소의 아래, 혹은 위쪽의 원소들이 모두 0인 행렬을 의미한다.

```
[[3, 5],    #상삼각 행렬
 [0, 2]]    
```

```
[[3, 0],    #하삼각 행렬
 [5, 2]]
```

### 그 외의 행렬들
이 외에도 띠 행렬*Band Matrix*, 특이 행렬*Singular Matrix*, 정칙 행렬*Non-Singular Matrix* 등이 있다.

## 역행렬 *Inverse Matrix*
정방 행렬 A에대하여 `AB = BA = I`를 만족하는 정방 행렬 B가 존재할 때, A는 가역*Invertible*이라 하고, B를 A의 역행렬이라 하며 A<sup>-1</sup>으로 표시한다. 또한, 가역이라함은 역행렬이 존재한다는 뜻이다.

### 역행렬 구하기
역행렬을 구하는 방법은 매우 다양한데, 일반적인 방법은 연립방정식을 이용해 푸는 것이다.

연립방정식을 푸는 방법은 가우스 소거법과 가우스-조던 소거법과 같이 직접적인 해를 구하는 방법과, 야코비*Jacobi* 방법과 가우스-자이델*Gauss-Seidel* 방법과 같이 반복적으로 해를 구하는 방법이 있다.

#### 가우스 조단 방법 *Gauss-Jordan Method*
행렬 `A=[[3,5],[2,3]]`의 역행렬을 구해보자.

먼저 증가 행렬*Argumented Matrix*을 만든다.
```
[[3, 5], :  [[1, 0],
 [2, 3]] :   [0, 1]]
```

1행 1열을 1로 만들기 위해 1행을 3으로 나누어서 1행을 다시 만든다.

```
[[1, 5/3], :  [[1/3, 0],
 [2, 3]] :   [0, 1]]
```

2행 1열을 0으로 만들기 위해 1행에 -2를 곱하고 2행에 더해서 2행을 다시 만든다.

```
[[1, 5/3], :  [[1/3, 0],
 [0, -1/3]] :   [-2/3, 1]]
```

2행 2열을 1로 만들기 위해 2열에 -3을 곱한다.

```
[[1, 5/3], :  [[1/3, 0],
 [0, 1]] :   [2, -3]]
```

1행 2열을 0으로 만들기 위해 2행에 -5/3을 곱하고 1행에 더한다.

```
[[1, 0], :  [[-3, 5],
 [0, 1]] :   [2, -3]]
```

따라서 행렬 A의 역행렬 A<sup>-1</sup>은 `[[-3, 5], [2, -3]]`이다.

#### 직교 행렬 *Orthogonal Matrix*
전치행렬이 직교행렬과 같은 행렬을 직교 행렬이라고 한다.

A<sup>T</sup> = A<sup>-1</sup>인 행렬은 직교 행렬이다.

## 부울 행렬 *Boolean Matrix*
부울 행렬은 모든 원소가 0과 1로 이루어진 행렬을 말한다.

부울 행렬의 연산과 부울 연산은 다르다. 부울 연산은 논리 연산이며 부울 행렬에서 사용하는 연산과는 다르다.

부울 행렬에서 사용하는 연산자는 접합, 교합, 부울곱의 세 가지 연산자가 있다.

### 접합 *Join*
A와 B의 접합은 다음과 같이 정의한다.

`A ∨ B = C`

(C<sub>ij</sub>)는 A<sub>ij</sub>=1 혹은 B<sub>ij</sub>=1 인 경우, 1이고 A<sub>ij</sub>와 B<sub>ij</sub>가 모두 0인 경우, 0이다.

### 교합 *Meet*
A와 B의 교합은 다음과 같이 정의한다.

`A ∧ B = C`

(C<sub>ij</sub>)는 A<sub>ij</sub>=1 이고 B<sub>ij</sub>=1 인 경우, 1이고 A<sub>ij</sub>와 B<sub>ij</sub> 중에 하나라도 0인 경우 0이다.

### 부울곱 *Boolean Product*
A와 B의 부울곱은 아래와 같이 정의한다.

`A ⊙ B = C`

행렬 A가 m x p의 부울 행렬이고, B가 p x n의 부울 행렬이면, A와 B의 부울곱은 m x n 부울 행렬이 되고, 다음과 같이 정의된다.

C<sub>ij</sub>에 대해, 어떤 k(1≤k≤p)에 대해, A<sub>ik</sub> = 1, B<sub>kj</sub> = 1 인 경우 1이고 이외에는 0이다.

## 행렬식 *Determinant*
A의 행렬식은 모든 정방 행렬 A에 대하여 고유한 수치 값을 대응시키는 것을 말하며, |A| 또는 det(A)로 표시한다.

2x2 행렬의 행렬식은 다음과 같이 정의한다.

```
det([[3, 2], [4, 6]] = 3*6 - 2*4 = 10
```

이 외에도 소행렬식*minor*과 여인수*cofactor* 개념이 있지만, 이들은 나중에 배워보자.

## 고유벡터와 고유값
어떤 벡터 V의 좌측에 행렬 A를 곱한 결과를 벡터 B로 나타낼 수 있다.

즉, 행렬 A를 이용하여 벡터 V를 벡터 B로 변환한 것이다. 이 과정을 선형 변환<sup>Linear Transformation</sup> 혹은 벡터 V를 벡터 B로 매핑<sup>mapping</sup>했다고 한다.

정방 행렬 A에 대해 AX = λX를 만족하는 X를 고유벡터<sup>eigen vector</sup>, 스칼라 λ를 고유값<sup>eigen value</sup>이라 한다.

행렬 A가 어떤 벡터 X에 선형 변환을 하는 선형 연산자일때, 해당 벡터 X에 대하여 λ만큼 확대하거나 축소한다는 의미이다.

n x n 행렬 A의 고유값(λ)을 구하기 위해 AX = λX를 AX = λIX로 수정하면 이는 `(λI-A)X=0`으로 쓸 수 있다.

λ가 고유값이 되기 위해서는 이 방정식에서 0이 아닌 해가 존재해야 한다. 0이 아닌 해를 갖기 위해서는 det(A-λI)=0이어야 한다. 이것을 A의 특성방정식<sup>characteristic equation</sup>이라 하고, 이 특정방정식을 만족하는 스칼라를 A의 고유값이라 한다.
